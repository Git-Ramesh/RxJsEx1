<html>

<head>
    <meta charset="UTF-8" />
    <title></title>
    <script src="rxjs.umd.js"></script>
    <script>
        const Rx = rxjs;
        const Op = rxjs.operators;
        const Ajax = rxjs.ajax;
        /////////////////////////////////////////////
        ///////////// combineLastest ///////////////
        ////////////////////////////////////////////

        // timerOne emits first value at 1s, then once every 4s
        // const timerOne$ = Rx.timer(1000, 4000);
        // // timerTwo emits first value at 2s, then once every 4s
        // const timerTwo$ = Rx.timer(2000, 4000);
        // // timerThree emits first value at 3s, then once every 4s
        // const timerThree$ = Rx.timer(3000, 4000);
        // Rx.combineLatest(timerOne$, timerTwo$, timerThree$).subscribe(([timerValOne, timerValTwo, timerValThree]) => {
        //     console.log(
        //         `Timer One Latest: ${timerValOne},
        //         Timer Two Latest: ${timerValTwo},
        //         Timer Three Latest: ${timerValThree}`
        //     );
        // });
        /////////////////////////////////////////////
        ///////////// ajax /////////////////////////
        ////////////////////////////////////////////
        // const githubUsers = `https://api.github.com/users?per_page=3`;
        // //  const users = Ajax.ajax(githubUsers).pipe(Op.delay(2000));
        // const users = Ajax.ajax.getJSON(githubUsers);
        // users.subscribe(resp => console.log(JSON.stringify(resp, undefined, 2)), err => console.log(err));
        // const githuberror = "https://api.github.com/error";
        // const errorUsers = Ajax.ajax.getJSON(githuberror);
        // errorUsers.subscribe(resp => console.log(resp), err => console.log(err));

        /////////////////////////////////////////////
        ///////////// create ///////////////////////
        ////////////////////////////////////////////
        //    const ob = Rx.Observable.create(observer => {
        //         observer.next("Hello");
        //         observer.next("World");
        //         observer.complete();
        //     }).pipe(Op.delay(3000));
        //     ob.subscribe(console.log);
        //    const ob =  Rx.Observable.create(observer => {
        //         let value = 0;
        //         setInterval(_ => {
        //             if(value % 2 === 0) {
        //                 observer.next(value);
        //             }
        //             value ++;
        //         }, 1000);
        //         // return () => clearInterval(interval)
        //     });
        //     const subscribe = ob.subscribe(console.log);
        //     setTimeout(() => {
        //         subscribe.unsubscribe();
        //     }, 10000);

        //////////////////////////////////////////////
        ///////////////// defer /////////////////////
        ////////////////////////////////////////////
        // Create an observable with given subscription function.
        // const s1 = Rx.of(new Date()); //will capture current date time
        // const s2 = Rx.defer(_ => Rx.of(new Date())); //will capture date time at the moment of subscription
        // console.log(new Date());
        // Rx.timer(2000)
        //     .pipe(Op.switchMap(_ => Rx.merge(s1, s2))).subscribe(console.log);

        //////////////////////////////////////////////
        ///////////////// empty /////////////////////
        ////////////////////////////////////////////
        // Observable that immediately completes.
        // const subscribe = Rx.empty().subscribe({
        //     next: _ => console.log("Next"),
        //     complete: _ => console.log("Complete!")
        // });

        /////////////////////////////////////////////
        ///////////////// from /////////////////////
        ////////////////////////////////////////////
        // Turn an array, promise, or iterable into an observable.
        // const arraySource = Rx.from([1, 2, 3, 4, 5]);
        // //output: 1,2,3,4,5
        // const subscribe = arraySource.subscribe(val => console.log(val));

        // //emit result of promise
        // const promiseSource = Rx.from(new Promise((resolve, reject) => resolve('Hello World!')));
        // //output: 'Hello World'
        // promiseSource.subscribe(val => console.log(val));
        // //  Observable from collection
        // const map = new Map();
        // map.set(1, 'Hai')
        // map.set(2, 'Bye!')
        // const mapSource = Rx.from(map);
        // mapSource.subscribe(console.log);
        // // Observable from string
        // const name = 'Ramesh';
        // Rx.from(name).subscribe(console.log);


        /////////////////////////////////////////////
        ///////////////// fromEvent ////////////////
        ///////////////////////////////////////////
        // Turn event into observable sequence
        // const eventSource = Rx.fromEvent(document, 'click');
        // const example = eventSource.pipe(Op.map(event => `Event time: ${event.timeStamp}`));
        // example.subscribe(val => console.log(val));


        ////////////////////////////////////////////
        ///////////////// interval ////////////////
        ///////////////////////////////////////////
        // Emit numbers in sequence based on provided timeframe.
        // const source = Rx.interval(1000);
        // source.subscribe(val => console.log(val));

        ////////////////////////////////////////////
        ///////////////// of //////////////////////
        ///////////////////////////////////////////
        // Emit variable amount of values in a sequence and then emits a complete notification.
        // const source = Rx.of(1, 2, 3, 4, 5, 6);
        // const subscribe = source.subscribe({
        //     next: (val) => console.log(val),
        //     complete: _ => console.log('Complete!')
        // });

        ////////////////////////////////////////////
        ///////////////// range //////////////////////
        ///////////////////////////////////////////
        // Emit numbers in provided range in sequence.
        // const source = Rx.range(1, 10);
        // const subscribe = source.subscribe({
        //     next: (val) => console.log(val),
        //     complete: _ => console.log('Complete!')
        // });

        ////////////////////////////////////////////
        ///////////////// throw ///////////////////
        //////////////////////////////////////////
        // Emit error on subscription.
        // const source = Rx.throwError('This is an error!');
        // const subscribe = source.subscribe({
        //     next: val => console.log(val),
        //     complete: () => console.log('Complete!'),
        //     error: val => console.log(`Error: ${val}`)
        // });

        ////////////////////////////////////////////
        ///////////////// throw ///////////////////
        //////////////////////////////////////////
        // After given duration, emit numbers in sequence every specified duration.

        // const source = Rx.timer(1000);
        // // /emit 0 after 1 second then complete, since no second argument is supplied
        // const subscribe = source.subscribe(val => console.log(val));

        /*
            timer takes a second argument, how often to emit subsequent values
            in this case we will emit first value after 1 second and subsequent
            values every 2 seconds after
        */
        const source = Rx.timer(1000, 2000);
        // output: 0,1,2,3,4,5......
        const subscribe = source.subscribe(val => console.log(val));
    </script>
</head>

<body>

</body>

</html>